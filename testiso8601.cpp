#include "iso8601.h"
#include <iostream>
#include <time.h>
#include <cmath>
#include <assert.h>
using namespace std;

void Iso8601TestCases(std::vector<std::string> &testStrs, std::vector<double> &testTimestamps)
{
	testStrs.clear();
	testTimestamps.clear();

	//POSIX time generated by:
	//https://coderstoolbox.net/unixtimestamp/
	//or python: calendar.timegm(datetime.parser.parse("2010-02-18T16:23.33").utctimetuple())

	testStrs.push_back("2017-09-11");
	testTimestamps.push_back(1505088000);
	
	testStrs.push_back("2017-09-11T21:52:13+00:00");
	testTimestamps.push_back(1505166733);

	testStrs.push_back("2017-09-11T21:52:13Z");
	testTimestamps.push_back(1505166733);

	testStrs.push_back("20170911T215213Z");
	testTimestamps.push_back(1505166733);

	testStrs.push_back("2009-12T12:34");
	testTimestamps.push_back(1259670840);

	//Subset of test cases from https://www.myintervals.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/
	testStrs.push_back("2009");
	testTimestamps.push_back(1230768000);

	testStrs.push_back("2009-05-19");
	testTimestamps.push_back(1242691200);

	testStrs.push_back("20090519");
	testTimestamps.push_back(1242691200);

	testStrs.push_back("2009-05");
	testTimestamps.push_back(1241136000);

	testStrs.push_back("2009-05-19T14:39Z");
	testTimestamps.push_back(1242743940);

	testStrs.push_back("20090621T0545Z");
	testTimestamps.push_back(1245563100);

	testStrs.push_back("2007-04-06T00:00");
	testTimestamps.push_back(1175817600);

	testStrs.push_back("2007-04-05T24:00");
	testTimestamps.push_back(1175817600);

	testStrs.push_back("2010-02-18T16:23:48.5");
	testTimestamps.push_back(1266510228.5);

	testStrs.push_back("2010-02-18T16:23.4");
	testTimestamps.push_back(1266510204);

	testStrs.push_back("2010-02-18T16:23+0600");
	testTimestamps.push_back(1266488580);

	testStrs.push_back("2010-02-18T16:23:35-0530");
	testTimestamps.push_back(1266530015);

	testStrs.push_back("2010-02-18T16.23334444");
	testTimestamps.push_back(1266509640);

	testStrs.push_back("2010-02-18T16.2233344445555");
	testTimestamps.push_back(1266509604.0040004);

	testStrs.push_back("2010-02-18T16.22333444455555666666");
	testTimestamps.push_back(1266509604.0040004);

	//Bad ISO8601 strings
	testStrs.push_back("200905");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009367");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-");
	testTimestamps.push_back(-1);

	testStrs.push_back("2007-04-05T24:50");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-000");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-M511");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009M511");
	testTimestamps.push_back(-1);

 	testStrs.push_back("2009-05-19T14a39r");
	testTimestamps.push_back(-1);
 
	testStrs.push_back("2009-05-19T14:3924");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-0519");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-1914:39");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19 14:");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19r14:39");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19 14a39a22");
	testTimestamps.push_back(-1);
 
	testStrs.push_back("200912-01");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19 14a39a22");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19 14:39:22+06a00");
	testTimestamps.push_back(-1);

	testStrs.push_back("2009-05-19 146922.500");
	testTimestamps.push_back(-1);

	testStrs.push_back("2010-02-18T16.5:23.35:48");
	testTimestamps.push_back(-1);

	testStrs.push_back("2010-02-18T16:23.35:48");
	testTimestamps.push_back(-1);

	testStrs.push_back("2010-02-18T16:23.35:48.45");
	testTimestamps.push_back(-1); 

	testStrs.push_back("2009-05-19 14.5.44");
	testTimestamps.push_back(-1); 

	testStrs.push_back("2010-02-18T16:23.33.600");
	testTimestamps.push_back(-1); 

	testStrs.push_back("2010-02-18T16,25:23:48,444");
	testTimestamps.push_back(-1);
}

int main()
{
	std::vector<std::string> testStrs;
	std::vector<double> testTimestamps;
	Iso8601TestCases(testStrs, testTimestamps);
	assert(testStrs.size() == testTimestamps.size());
	
	int errors = 0;
	for(size_t i=0; i<testStrs.size(); i++)
	{
		cout << "Test case: " << testStrs[i] << endl;
		struct tm dt;
		bool ok = ParseIso8601Datetime(testStrs[i].c_str(), dt);
		if(!ok)
		{
			if(testTimestamps[i] < 0.0)
				cout << "Parse fail as expected" << endl;
			else
			{
				cout << "Parse FAIL as NOT EXPECTED" << endl;
				errors++;
			}
			continue;
		}
		else
		{
			if(testTimestamps[i] < 0.0)
			{
				cout << "Parse should have FAILED" << endl;
				errors ++;
				continue;
			}
		}

		time_t ts = mktime (&dt);
		//cout << 1900+dt.tm_year << "," << 1+dt.tm_mon << "," << dt.tm_mday << "," << dt.tm_hour << "," << dt.tm_min << "," << dt.tm_sec << endl;

		cout << ctime(&ts);// UTC date+time string
		cout << (int64_t)ts << "=" << (int64_t)round(testTimestamps[i]); //UTC unix time-stamp
		if(fabs((int64_t)ts - round(testTimestamps[i]))>1e-6) cout << " FAIL";
		cout << endl;
	}
	cout << "Errors " << errors << endl;
}

